{"version":3,"sources":["meteor://ðŸ’»app/packages/promise/server.js","meteor://ðŸ’»app/packages/promise/common.js","meteor://ðŸ’»app/../npm/node_modules/meteor-promise/package.json","meteor://ðŸ’»app/node_modules/meteor/promise/node_modules/meteor-promise/promise_server.js","meteor://ðŸ’»app/node_modules/meteor/promise/node_modules/meteor-promise/fiber_pool.js","meteor://ðŸ’»app/node_modules/meteor/promise/node_modules/promise/lib/es6-extensions.js","meteor://ðŸ’»app/node_modules/meteor/promise/node_modules/promise/lib/core.js","meteor://ðŸ’»app/node_modules/meteor/promise/node_modules/promise/node_modules/asap/raw.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpBA;AACA;AACA;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/packages/promise.js","sourcesContent":["require(\"meteor-promise\").makeCompatible(\n  exports.Promise = require(\"./common.js\").Promise,\n  // Allow every Promise callback to run in a Fiber drawn from a pool of\n  // reusable Fibers.\n  require(\"fibers\")\n);\n","var global = this;\n\nif (typeof global.Promise === \"function\") {\n  exports.Promise = global.Promise;\n} else {\n  exports.Promise = require(\"promise/lib/es6-extensions\");\n}\n\nexports.Promise.prototype.done = function (onFulfilled, onRejected) {\n  var self = this;\n\n  if (arguments.length > 0) {\n    self = this.then.apply(this, arguments);\n  }\n\n  self.then(null, function (err) {\n    Meteor._setImmediate(function () {\n      throw err;\n    });\n  });\n};\n","exports.name = \"meteor-promise\";\nexports.version = \"0.7.2\";\nexports.main = \"promise_server.js\";\n","var assert = require(\"assert\");\nvar fiberPool = require(\"./fiber_pool.js\").makePool();\n\nexports.makeCompatible = function (Promise, Fiber) {\n  var es6PromiseThen = Promise.prototype.then;\n\n  if (typeof Fiber === \"function\") {\n    Promise.Fiber = Fiber;\n  }\n\n  // Replace Promise.prototype.then with a wrapper that ensures the\n  // onResolved and onRejected callbacks always run in a Fiber.\n  Promise.prototype.then = function (onResolved, onRejected) {\n    var P = this.constructor;\n\n    if (typeof P.Fiber === \"function\") {\n      var fiber = P.Fiber.current;\n      var dynamics = cloneFiberOwnProperties(fiber);\n\n      return es6PromiseThen.call(\n        this,\n        wrapCallback(onResolved, P, dynamics),\n        wrapCallback(onRejected, P, dynamics)\n      );\n    }\n\n    return es6PromiseThen.call(this, onResolved, onRejected);\n  };\n\n  Promise.awaitAll = function (args) {\n    return awaitPromise(this.all(args));\n  };\n\n  Promise.await = function (arg) {\n    return awaitPromise(this.resolve(arg));\n  };\n\n  Promise.prototype.await = function () {\n    return awaitPromise(this);\n  };\n\n  // Yield the current Fiber until the given Promise has been fulfilled.\n  function awaitPromise(promise) {\n    var Promise = promise.constructor;\n    var Fiber = Promise.Fiber;\n\n    assert.strictEqual(\n      typeof Fiber, \"function\",\n      \"Cannot await unless Promise.Fiber is defined\"\n    );\n\n    var fiber = Fiber.current;\n\n    assert.ok(\n      fiber instanceof Fiber,\n      \"Cannot await without a Fiber\"\n    );\n\n    var run = fiber.run;\n    var throwInto = fiber.throwInto;\n\n    if (process.domain) {\n      run = process.domain.bind(run);\n      throwInto = process.domain.bind(throwInto);\n    }\n\n    // The overridden es6PromiseThen function is adequate here because these\n    // two callbacks do not need to run in a Fiber.\n    es6PromiseThen.call(promise, function (result) {\n      tryCatchNextTick(fiber, run, [result]);\n    }, function (error) {\n      tryCatchNextTick(fiber, throwInto, [error]);\n    });\n\n    return Fiber.yield();\n  }\n\n  // Return a wrapper function that returns a Promise for the eventual\n  // result of the original function.\n  Promise.async = function (fn, allowReuseOfCurrentFiber) {\n    var Promise = this;\n    return function () {\n      return Promise.asyncApply(\n        fn, this, arguments,\n        allowReuseOfCurrentFiber\n      );\n    };\n  };\n\n  Promise.asyncApply = function (\n    fn, context, args, allowReuseOfCurrentFiber\n  ) {\n    var Promise = this;\n    var Fiber = Promise.Fiber;\n    var fiber = Fiber && Fiber.current;\n\n    if (fiber && allowReuseOfCurrentFiber) {\n      return this.resolve(fn.apply(context, args));\n    }\n\n    return fiberPool.run({\n      callback: fn,\n      context: context,\n      args: args,\n      dynamics: cloneFiberOwnProperties(fiber)\n    }, Promise);\n  };\n};\n\nfunction wrapCallback(callback, Promise, dynamics) {\n  if (! callback) {\n    return callback;\n  }\n\n  return function (arg) {\n    return fiberPool.run({\n      callback: callback,\n      args: [arg], // Avoid dealing with arguments objects.\n      dynamics: dynamics\n    }, Promise);\n  };\n}\n\nfunction cloneFiberOwnProperties(fiber) {\n  if (fiber) {\n    var dynamics = {};\n\n    Object.keys(fiber).forEach(function (key) {\n      dynamics[key] = shallowClone(fiber[key]);\n    });\n\n    return dynamics;\n  }\n}\n\nfunction shallowClone(value) {\n  if (Array.isArray(value)) {\n    return value.slice(0);\n  }\n\n  if (value && typeof value === \"object\") {\n    var copy = Object.create(Object.getPrototypeOf(value));\n    var keys = Object.keys(value);\n    var keyCount = keys.length;\n\n    for (var i = 0; i < keyCount; ++i) {\n      var key = keys[i];\n      copy[key] = value[key];\n    }\n\n    return copy;\n  }\n\n  return value;\n}\n\n// Invoke method with args against object in a try-catch block,\n// re-throwing any exceptions in the next tick of the event loop, so that\n// they won't get captured/swallowed by the caller.\nfunction tryCatchNextTick(object, method, args) {\n  try {\n    return method.apply(object, args);\n  } catch (error) {\n    process.nextTick(function () {\n      throw error;\n    });\n  }\n}\n","var assert = require(\"assert\");\n\nfunction FiberPool(targetFiberCount) {\n  assert.ok(this instanceof FiberPool);\n  assert.strictEqual(typeof targetFiberCount, \"number\");\n\n  var fiberStack = [];\n\n  function makeNewFiber(Fiber) {\n    // Just in case someone tampers with Fiber.yield, don't let that interfere\n    // with our processing of the callback queue.\n    var originalYield = Fiber.yield;\n\n    var fiber = new Fiber(function () {\n      while (true) {\n        // Call Fiber.yield() to await further instructions.\n        var entry = originalYield.call(Fiber);\n\n        // Ensure this Fiber is no longer in the pool once it begins to\n        // execute an entry.\n        assert.strictEqual(fiberStack.indexOf(fiber), -1);\n\n        if (entry.dynamics) {\n          // Restore the dynamic environment of this fiber as if\n          // entry.callback had been wrapped by Meteor.bindEnvironment.\n          Object.keys(entry.dynamics).forEach(function (key) {\n            fiber[key] = entry.dynamics[key];\n          });\n        }\n\n        try {\n          var result = entry.callback.apply(\n            entry.context || null,\n            entry.args || []\n          );\n\n          setImmediate(entry.resolve.bind(entry, result));\n\n        } catch (error) {\n          entry.reject(error);\n        }\n\n        // Remove all own properties of the fiber before returning it to\n        // the pool.\n        Object.keys(fiber).forEach(function (key) {\n          delete fiber[key];\n        });\n\n        if (fiberStack.length < targetFiberCount) {\n          fiberStack.push(fiber);\n        } else {\n          // If the pool has already reached the target maximum number of\n          // Fibers, don't bother recycling this Fiber.\n          break;\n        }\n      }\n    });\n\n    // Run the new Fiber up to the first yield point, so that it will be\n    // ready to receive entries.\n    fiber.run();\n\n    return fiber;\n  }\n\n  // Run the entry.callback function in a Fiber either taken from the pool\n  // or created anew if the pool is empty. This method returns a Promise\n  // for the eventual result of the entry.callback function.\n  this.run = function (entry, Promise) {\n    assert.strictEqual(typeof entry, \"object\");\n    assert.strictEqual(typeof entry.callback, \"function\");\n\n    if (typeof Promise.Fiber !== \"function\") {\n      return new Promise(function (resolve) {\n        resolve(entry.callback.apply(\n          entry.context || null,\n          entry.args\n        ));\n      });\n    }\n\n    var fiber = fiberStack.pop() || makeNewFiber(Promise.Fiber);\n\n    var promise = new Promise(function (resolve, reject) {\n      entry.resolve = resolve;\n      entry.reject = reject;\n    });\n\n    fiber.run(entry);\n\n    return promise;\n  };\n\n  // Limit the maximum number of idle Fibers that may be kept in the\n  // pool. Note that the run method will never refuse to create a new\n  // Fiber if the pool is empty; it's just that excess Fibers might be\n  // thrown away upon completion, if the pool is full.\n  this.setTargetFiberCount = function (limit) {\n    assert.strictEqual(typeof limit, \"number\");\n\n    targetFiberCount = Math.max(limit, 0);\n\n    if (targetFiberCount < fiberStack.length) {\n      // If the requested target count is less than the current length of\n      // the stack, truncate the stack and terminate any surplus Fibers.\n      fiberStack.splice(targetFiberCount).forEach(function (fiber) {\n        fiber.reset();\n      });\n    }\n\n    return this;\n  };\n}\n\n// Call pool.drain() to terminate all Fibers waiting in the pool and\n// signal to any outstanding Fibers that they should exit upon completion,\n// instead of reinserting themselves into the pool.\nFiberPool.prototype.drain = function () {\n  return this.setTargetFiberCount(0);\n};\n\nexports.makePool = function (targetFiberCount) {\n  return new FiberPool(targetFiberCount || 20);\n};\n","'use strict';\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nvar TRUE = valuePromise(true);\nvar FALSE = valuePromise(false);\nvar NULL = valuePromise(null);\nvar UNDEFINED = valuePromise(undefined);\nvar ZERO = valuePromise(0);\nvar EMPTYSTRING = valuePromise('');\n\nfunction valuePromise(value) {\n  var p = new Promise(Promise._61);\n  p._81 = 1;\n  p._65 = value;\n  return p;\n}\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value;\n\n  if (value === null) return NULL;\n  if (value === undefined) return UNDEFINED;\n  if (value === true) return TRUE;\n  if (value === false) return FALSE;\n  if (value === 0) return ZERO;\n  if (value === '') return EMPTYSTRING;\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then;\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value));\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex);\n      });\n    }\n  }\n  return valuePromise(value);\n};\n\nPromise.all = function (arr) {\n  var args = Array.prototype.slice.call(arr);\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n    function res(i, val) {\n      if (val && (typeof val === 'object' || typeof val === 'function')) {\n        if (val instanceof Promise && val.then === Promise.prototype.then) {\n          while (val._81 === 3) {\n            val = val._65;\n          }\n          if (val._81 === 1) return res(i, val._65);\n          if (val._81 === 2) reject(val._65);\n          val.then(function (val) {\n            res(i, val);\n          }, reject);\n          return;\n        } else {\n          var then = val.then;\n          if (typeof then === 'function') {\n            var p = new Promise(then.bind(val));\n            p.then(function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n      }\n      args[i] = val;\n      if (--remaining === 0) {\n        resolve(args);\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) {\n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    });\n  });\n};\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n","'use strict';\n\nvar asap = require('asap/raw');\n\nfunction noop() {}\n\n// States:\n//\n// 0 - pending\n// 1 - fulfilled with _value\n// 2 - rejected with _value\n// 3 - adopted the state of another promise, _value\n//\n// once the state is no longer pending (0) it is immutable\n\n// All `_` prefixed properties will be reduced to `_{random number}`\n// at build time to obfuscate them and discourage their use.\n// We don't use symbols or Object.defineProperty to fully hide them\n// because the performance isn't good enough.\n\n\n// to avoid using try/catch inside critical functions, we\n// extract them to here.\nvar LAST_ERROR = null;\nvar IS_ERROR = {};\nfunction getThen(obj) {\n  try {\n    return obj.then;\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nfunction tryCallOne(fn, a) {\n  try {\n    return fn(a);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\nfunction tryCallTwo(fn, a, b) {\n  try {\n    fn(a, b);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nmodule.exports = Promise;\n\nfunction Promise(fn) {\n  if (typeof this !== 'object') {\n    throw new TypeError('Promises must be constructed via new');\n  }\n  if (typeof fn !== 'function') {\n    throw new TypeError('not a function');\n  }\n  this._45 = 0;\n  this._81 = 0;\n  this._65 = null;\n  this._54 = null;\n  if (fn === noop) return;\n  doResolve(fn, this);\n}\nPromise._10 = null;\nPromise._97 = null;\nPromise._61 = noop;\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  if (this.constructor !== Promise) {\n    return safeThen(this, onFulfilled, onRejected);\n  }\n  var res = new Promise(noop);\n  handle(this, new Handler(onFulfilled, onRejected, res));\n  return res;\n};\n\nfunction safeThen(self, onFulfilled, onRejected) {\n  return new self.constructor(function (resolve, reject) {\n    var res = new Promise(noop);\n    res.then(resolve, reject);\n    handle(self, new Handler(onFulfilled, onRejected, res));\n  });\n};\nfunction handle(self, deferred) {\n  while (self._81 === 3) {\n    self = self._65;\n  }\n  if (Promise._10) {\n    Promise._10(self);\n  }\n  if (self._81 === 0) {\n    if (self._45 === 0) {\n      self._45 = 1;\n      self._54 = deferred;\n      return;\n    }\n    if (self._45 === 1) {\n      self._45 = 2;\n      self._54 = [self._54, deferred];\n      return;\n    }\n    self._54.push(deferred);\n    return;\n  }\n  handleResolved(self, deferred);\n}\n\nfunction handleResolved(self, deferred) {\n  asap(function() {\n    var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      if (self._81 === 1) {\n        resolve(deferred.promise, self._65);\n      } else {\n        reject(deferred.promise, self._65);\n      }\n      return;\n    }\n    var ret = tryCallOne(cb, self._65);\n    if (ret === IS_ERROR) {\n      reject(deferred.promise, LAST_ERROR);\n    } else {\n      resolve(deferred.promise, ret);\n    }\n  });\n}\nfunction resolve(self, newValue) {\n  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n  if (newValue === self) {\n    return reject(\n      self,\n      new TypeError('A promise cannot be resolved with itself.')\n    );\n  }\n  if (\n    newValue &&\n    (typeof newValue === 'object' || typeof newValue === 'function')\n  ) {\n    var then = getThen(newValue);\n    if (then === IS_ERROR) {\n      return reject(self, LAST_ERROR);\n    }\n    if (\n      then === self.then &&\n      newValue instanceof Promise\n    ) {\n      self._81 = 3;\n      self._65 = newValue;\n      finale(self);\n      return;\n    } else if (typeof then === 'function') {\n      doResolve(then.bind(newValue), self);\n      return;\n    }\n  }\n  self._81 = 1;\n  self._65 = newValue;\n  finale(self);\n}\n\nfunction reject(self, newValue) {\n  self._81 = 2;\n  self._65 = newValue;\n  if (Promise._97) {\n    Promise._97(self, newValue);\n  }\n  finale(self);\n}\nfunction finale(self) {\n  if (self._45 === 1) {\n    handle(self, self._54);\n    self._54 = null;\n  }\n  if (self._45 === 2) {\n    for (var i = 0; i < self._54.length; i++) {\n      handle(self, self._54[i]);\n    }\n    self._54 = null;\n  }\n}\n\nfunction Handler(onFulfilled, onRejected, promise){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, promise) {\n  var done = false;\n  var res = tryCallTwo(fn, function (value) {\n    if (done) return;\n    done = true;\n    resolve(promise, value);\n  }, function (reason) {\n    if (done) return;\n    done = true;\n    reject(promise, reason);\n  })\n  if (!done && res === IS_ERROR) {\n    done = true;\n    reject(promise, LAST_ERROR);\n  }\n}\n","\"use strict\";\n\nvar domain; // The domain module is executed on demand\nvar hasSetImmediate = typeof setImmediate === \"function\";\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including network IO events in Node.js.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Avoids a function call\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory excaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\nrawAsap.requestFlush = requestFlush;\nfunction requestFlush() {\n    // Ensure flushing is not bound to any domain.\n    // It is not sufficient to exit the domain, because domains exist on a stack.\n    // To execute code outside of any domain, the following dance is necessary.\n    var parentDomain = process.domain;\n    if (parentDomain) {\n        if (!domain) {\n            // Lazy execute the domain module.\n            // Only employed if the user elects to use domains.\n            domain = require(\"domain\");\n        }\n        domain.active = process.domain = null;\n    }\n\n    // `setImmediate` is slower that `process.nextTick`, but `process.nextTick`\n    // cannot handle recursion.\n    // `requestFlush` will only be called recursively from `asap.js`, to resume\n    // flushing after an error is thrown into a domain.\n    // Conveniently, `setImmediate` was introduced in the same version\n    // `process.nextTick` started throwing recursion errors.\n    if (flushing && hasSetImmediate) {\n        setImmediate(flush);\n    } else {\n        process.nextTick(flush);\n    }\n\n    if (parentDomain) {\n        domain.active = process.domain = parentDomain;\n    }\n}\n"]}